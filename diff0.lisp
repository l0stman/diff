(defun common-subseq (f1 f2)
  "Find the indexes of the longest common subsequence between the
files f1 and f2 represented as arrays.  This algorithm is O(mn)."
  (labels ((iter (i j)
             (cond ((or (minusp i) (minusp j))
                    (values (list (cons 0 0))
                            0))
                   ((string= (aref f1 i) (aref f2 j))
                    (multiple-value-bind (seq len) (iter (1- i) (1- j))
                      (values (cons (cons (1+ i) (1+ j))
                                    seq)
                              (1+ len))))
                   (t (multiple-value-bind (seq1 len1) (iter (1- i) j)
                        (multiple-value-bind (seq2 len2) (iter i (1- j))
                          (if (< len1 len2)
                              (values seq2 len2)
                              (values seq1 len1))))))))
    (let ((len1 (length f1)) (len2 (length f2)))
     (nreverse
      (cons (cons (1+ len1) (1+ len2))
            (iter (1- len1) (1- len2)))))))

(defun delta (seq)
  "Transform the indexes of the longest common subsequence into
notation using `a' for append, `d' for delete and `c' for change."
  (loop for ((i1 . j1) (i2 . j2)) on seq
     when (and i2 (or (/= (1+ i1) i2) (/= (1+ j1) j2)))
     collect (cond ((= (1+ i1) i2)
                    (list 'a i1 (1+ j1) (1- j2)))
                   ((= (1+ j1) j2)
                    (list 'd (1+ i1) (1- i2) j1))
                   (t
                    (list 'c (1+ i1) (1- i2) (1+ j1) (1- j2))))))

(defmacro aif (pred then &optional else)
  `(let ((it ,pred))
     (if it ,then ,else)))

(defun file->arr (file)
  (with-open-file (in file)
    (loop with arr = (make-array 0 :adjustable t :fill-pointer 0)
       do (aif (read-line in nil)
               (vector-push-extend it arr)
               (return arr)))))

(defun diff (file1 file2)
  (let ((f1 (file->arr file1))
        (f2 (file->arr file2)))
   (flet ((print-range (f min max sym)
            (loop for i from (1- min) to (1- max)
               do (format t "~A ~A~%" sym (aref f i)))))
     (dolist (d (delta (common-subseq f1 f2)))
       (case (car d)
         (a (let ((min (third d))
                  (max (fourth d)))
              (format t "~Da~D,~D~%" (second d) min max)
              (print-range f2 min max '>)))
         (d (let ((min (second d))
                  (max (third d)))
              (format t "~D,~Dd~D~%" min max (fourth d))
              (print-range f1 min max '<)))
         (c (let ((min1 (second d))
                  (max1 (third d))
                  (min2 (fourth d))
                  (max2 (fifth d)))
              (format t "~D,~Dc~D,~D~%" min1 max1 min2 max2)
              (print-range f1 min1 max1 '<)
              (format t "---~%")
              (print-range f2 min2 max2 '>))))))))
