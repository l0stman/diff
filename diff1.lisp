(defstruct line
  (serial 0 :type fixnum)
  (hash 0 :type fixnum))

(defstruct eqv
  (serial 0 :type fixnum)
  (lastp t :type boolean))

(defun assoc-eqv-class (f1 f2)
  (let ((lines (make-array (length f2))))
    (dotimes (i (length f2))
      (setf (aref lines i)
            (make-line :serial (1+ i) :hash (sxhash (aref f2 i)))))
    (setq lines (sort lines
                      (lambda (l1 l2)
                        (or (< (line-hash l1) (line-hash l2))
                            (and (= (line-hash l1) (line-hash l2))
                                 (< (line-serial l1) (line-serial l2)))))))
    (let ((eqvs (make-array (1+ (length f2)))))
      (setf (aref eqvs 0) (make-eqv))
      (dotimes (i (length f2))
        (setf (aref eqvs (1+ i))
              (make-eqv :serial (line-serial (aref lines i))
                        :lastp (or (= i (1- (length f2)))
                                   (/= (line-hash (aref lines i))
                                       (line-hash (aref lines (1+ i))))))))
      (flet ((bsearch (h)
               (do ((min 0) (max (1- (length lines))))
                   ((> min max) 0)
                 (let* ((mid (ash (+ min max) -1))
                        (d (- h (line-hash (aref lines mid)))))
                   (cond ((and (eqv-lastp (aref eqvs mid))
                               (zerop d))
                          (return-from bsearch (1+ mid)))
                         ((<= d 0) (setq max (1- mid)))
                         (t (setq min (1+ mid))))))))
        (let ((P (make-array (length f1))))
          (dotimes (i (length f1) (values eqvs P))
            (setf (aref P i)
                  (bsearch (sxhash (aref f1 i))))))))))

(defmacro when-bind ((var expr) &body body)
  `(let ((,var ,expr))
     (when ,var ,@body)))

(defstruct cand
  (serial1 0 :type fixnum)
  (serial2 0 :type fixnum)
  (previous nil :type (or cand null)))

(defun mergec (cands k i eqvs p)
  (declare (optimize speed))
  (declare ((simple-array cand) cands))
  (let ((r 0) (c (aref cands 0)))
    (labels ((serial2 (s)
               (cand-serial2 (aref cands s)))
             (bsearch (j min max)
               (declare (fixnum min max))
               (loop
                  do (if (> min max)
                         (return-from bsearch nil)
                         (let ((mid (ash (+ min max) -1)))
                           (cond ((and (< (serial2 mid) j)
                                       (> (serial2 (1+ mid)) j))
                                  (return-from bsearch mid))
                                 ((>= (serial2 mid) j) (setq max (1- mid)))
                                 (t (setq min (1+ mid)))))))))
      (declare (inline serial2))
      (declare ((simple-array eqv) eqvs))
      (loop with j
         do (progn
              (setq j (eqv-serial (aref eqvs p)))
              (when-bind (s (bsearch j r k))
                (psetf (aref cands r) c
                       r (1+ s)
                       c (make-cand :serial1 i
                                    :serial2 j
                                    :previous (aref cands s)))
                (when (= s k)
                  (psetf (aref cands (+ k 2)) (aref cands (1+ k)) ; move fence
                         k (1+ k))
                  (return)))
              (if (eqv-lastp (aref eqvs p)) (return) (incf p))))
      (setf (aref cands r) c)
      k)))

(defun k-candidates (f1 f2)
  (multiple-value-bind (eqvs P) (assoc-eqv-class f1 f2)
    (let* ((len1 (length f1))
           (len2 (length f2))
           (cands (make-array (+ 2 (min len1 len2))))
           (k 0))
      (setf (aref cands 0) (make-cand)
            (aref cands 1) (make-cand :serial1 (1+ len1) :serial2 (1+ len2)))
      (dotimes (i len1 (values cands k))
        (when (plusp (aref P i))
          (setq k (mergec cands k (1+ i) eqvs (aref P i))))))))

(defun com-seq (f1 f2)
  (multiple-value-bind (cands k) (k-candidates f1 f2)
    (let ((seq (make-array (+ (length f1) 2) :element-type 'fixnum)))
      (do ((c (aref cands k) (cand-previous c)))
          ((null c) (setf (aref seq (1+ (length f1))) (1+ (length f2))))
        (setf (aref seq (cand-serial1 c)) (cand-serial2 c)))
      ;; Weed out jackpots.
      (loop with len = (1+ (length f1))
         for i from 0 to len
         when (or (zerop i)
                  (= i len)
                  (and (plusp (aref seq i))
                       (string= (aref f1 (1- i))
                                (aref f2 (1- (aref seq i))))))
         collect (cons i (aref seq i))))))

(defun delta (seq)
  "Transform the indexes of the longest common subsequence into
notation using `a' for append, `d' for delete and `c' for change."
  (loop for ((i1 . j1) (i2 . j2)) on seq
     when (and i2 (or (/= (1+ i1) i2) (/= (1+ j1) j2)))
     collect (cond ((= (1+ i1) i2)
                    (list 'a i1 (1+ j1) (1- j2)))
                   ((= (1+ j1) j2)
                    (list 'd (1+ i1) (1- i2) j1))
                   (t
                    (list 'c (1+ i1) (1- i2) (1+ j1) (1- j2))))))

(defmacro aif (pred then &optional else)
  `(let ((it ,pred))
     (if it ,then ,else)))

(defun file->arr (file)
  (with-open-file (in file)
    (loop with arr = (make-array 0 :adjustable t :fill-pointer 0)
       do (aif (read-line in nil)
               (vector-push-extend it arr)
               (return arr)))))

(defun diff (file1 file2)
  (let ((f1 (file->arr file1))
        (f2 (file->arr file2)))
   (flet ((print-range (f min max sym)
            (loop for i from (1- min) to (1- max)
               do (format t "~A ~A~%" sym (aref f i)))))
     (dolist (d (delta (com-seq f1 f2)))
       (case (car d)
         (a (let ((min (third d))
                  (max (fourth d)))
              (format t "~Da~D,~D~%" (second d) min max)
              (print-range f2 min max '>)))
         (d (let ((min (second d))
                  (max (third d)))
              (format t "~D,~Dd~D~%" min max (fourth d))
              (print-range f1 min max '<)))
         (c (let ((min1 (second d))
                  (max1 (third d))
                  (min2 (fourth d))
                  (max2 (fifth d)))
              (format t "~D,~Dc~D,~D~%" min1 max1 min2 max2)
              (print-range f1 min1 max1 '<)
              (format t "---~%")
              (print-range f2 min2 max2 '>))))))))
